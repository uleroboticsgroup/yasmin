<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concurrence (Python) - YASMIN</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../sidebar.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="../../dark_mode.js"></script>
</head>
<body>
    <header>
        <a href="../../index.html" class="logo">
            <img src="../../logo.png" alt="YASMIN Logo">
            YASMIN
        </a>
        <div class="nav-links">
            <a href="../../index.html">Docs</a>
            <a href="https://github.com/uleroboticsgroup/yasmin" target="_blank">GitHub</a>
            <a href="../../doxygen.html" target="_blank">Doxygen</a>
            <button id="theme-toggle" title="Toggle Dark Mode">ðŸŒ™</button>
        </div>
    </header>

    <div class="container">
                        <nav class="sidebar">
            <h3>Getting Started</h3>
            <ul>
                <li><a href="../../index.html">Introduction</a></li>
                <li><a href="../../main_concepts.html">Main Concepts</a></li>
                <li><a href="../../packages.html">Packages Overview</a></li>
                <li><a href="../../docker.html">Docker</a></li>
                <li><a href="../../xml_factory.html">XML</a></li>
            </ul>
            
            <h3>Tutorials</h3>
            <ul>
                <li><a href="../../tutorials.html">All Tutorials</a></li>
            </ul>

            <h3 class="collapsible">C++ Tutorials</h3>
            <ul>
                <li><a href="../cpp/basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="../cpp/remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="../cpp/concurrence_demo.html">Concurrence</a></li>
                <li><a href="../cpp/service_client_demo.html">Service Client</a></li>
                <li><a href="../cpp/action_client_demo.html">Action Client</a></li>
                <li><a href="../cpp/monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="../cpp/publisher_demo.html">Publisher</a></li>
                <li><a href="../cpp/parameters_demo.html">ROS Parameters</a></li>
                <li><a href="../cpp/nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="../cpp/factory_demo.html">Factory (XML)</a></li>
            </ul>

            <h3 class="collapsible">Python Tutorials</h3>
            <ul>
                <li><a href="basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="concurrence_demo.html">Concurrence</a></li>
                <li><a href="service_client_demo.html">Service Client</a></li>
                <li><a href="action_client_demo.html">Action Client</a></li>
                <li><a href="monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="publisher_demo.html">Publisher</a></li>
                <li><a href="parameters_demo.html">ROS Parameters</a></li>
                <li><a href="nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="factory_demo.html">Factory (XML)</a></li>
            </ul>
            
            <h3>Tools</h3>
            <ul>
                <li><a href="../../yasmin_editor.html">YASMIN Editor</a></li>
                <li><a href="../../yasmin_factory.html">YASMIN Factory</a></li>
                <li><a href="../../yasmin_viewer.html">YASMIN Viewer</a></li>
            </ul>

            <h3>Resources</h3>
            <ul>
                <li><a href="../../citations.html">Citations</a></li>
            </ul>
        </nav>

        <main class="main-content content">
            <h1><a href="https://github.com/uleroboticsgroup/yasmin/blob/main/yasmin_demos/yasmin_demos/concurrence_demo.py" target="_blank" style="color: inherit; text-decoration: none;">Concurrence Demo (Python)</a></h1>
            <p>This tutorial demonstrates how to run multiple states concurrently using YASMIN's <code>Concurrence</code> container. Concurrence allows you to execute multiple states in parallel and define outcome mappings based on the results of these states. This is essential in robotics for scenarios like monitoring multiple sensors simultaneously, executing independent behaviors in parallel, or waiting for multiple conditions to be satisfied before proceeding. The Concurrence container handles all the complexity of thread management, synchronization, and outcome resolution, providing a clean interface for parallel state execution.</p>

            <h2>Background</h2>
            <p>The <strong>Concurrence</strong> container enables parallel execution of multiple states. It is useful when you need to:</p>
            <ul>
                <li>Execute independent tasks simultaneously without blocking each other</li>
                <li>Wait for multiple conditions to be met (AND/OR logic)</li>
                <li>Coordinate parallel behaviors with custom outcome logic</li>
                <li>Implement timeout patterns where one state monitors time while another performs work</li>
                <li>Monitor sensors while executing actions (e.g., watch for obstacles while navigating)</li>
            </ul>

            <h2>1. Create the FooState</h2>
            <p>This state increments a counter and returns different outcomes based on the counter value. It executes relatively quickly (2 seconds) and stores a formatted string in the blackboard. The three different outcomes (<code>"outcome1"</code>, <code>"outcome2"</code>, <code>"outcome3"</code>) demonstrate how concurrent states can progress through stages and produce varying results. The counter is incremented after determining the outcome, so the state's behavior evolves with each execution. This pattern is useful for tasks that have distinct phases or thresholds, like collecting sensor samples, performing iterations of a computation, or tracking progress toward a goal.</p>

            <pre><code class="language-python">class FooState(State):
    """
    Represents the Foo state in the state machine.

    Attributes:
        counter (int): Counter to track the number of executions of this state.
    """

    def __init__(self) -> None:
        """
        Initializes the FooState instance, setting up the outcomes.

        Outcomes:
            outcome1: Indicates the state should continue.
            outcome2: Indicates the state should cotninue.
            outcome3: Indicates the state should finish execution and return.
        """
        super().__init__(["outcome1", "outcome2", "outcome3"])
        self.counter = 0

    def execute(self, blackboard: Blackboard) -> str:
        """
        Executes the logic for the Foo state.

        Args:
            blackboard (Blackboard): The shared data structure for states.

        Returns:
            str: The outcome of the execution.

        Raises:
            Exception: May raise exceptions related to state execution.
        """
        yasmin.YASMIN_LOG_INFO("Executing state FOO")
        time.sleep(2)

        blackboard["foo_str"] = f"Counter: {self.counter}"

        if self.counter < 3:
            outcome = "outcome1"
        elif self.counter < 5:
            outcome = "outcome2"
        else:
            outcome = "outcome3"

        yasmin.YASMIN_LOG_INFO("Finishing state FOO")
        self.counter += 1
        return outcome</code></pre>

            <h2>2. Create the BarState</h2>
            <p>This state takes longer to execute (4 seconds) and attempts to read from the blackboard. The key point here is demonstrating concurrent access to shared data. Since BarState takes twice as long as FooState, there's a race condition in the first execution - BarState might try to read <code>foo_str</code> before FooState has written it. We handle this safely with the <code>in</code> operator to check if the key exists. This illustrates an important principle in concurrent programming: always assume data might not be available yet. BarState consistently returns <code>"outcome3"</code>, providing stable behavior that contrasts with FooState's variable outcomes. The logs help visualize the parallel execution - you'll see "Executing state FOO" and "Executing state BAR" at similar times.</p>

            <pre><code class="language-python">class BarState(State):
    """
    Represents the Bar state in the state machine.
    """

    def __init__(self) -> None:
        """
        Initializes the BarState instance, setting up the outcome.

        Outcomes:
            outcome3: This state will always return this outcome
        """
        super().__init__(outcomes=["outcome3"])

    def execute(self, blackboard: Blackboard) -> str:
        """
        Executes the logic for the Bar state.

        Args:
            blackboard (Blackboard): The shared data structure for states.

        Returns:
            str: The outcome of the execution, which will always be "outcome3".

        Raises:
            Exception: May raise exceptions related to state execution.
        """
        yasmin.YASMIN_LOG_INFO("Executing state BAR")
        time.sleep(4)

        if "foo_str" in blackboard:
            yasmin.YASMIN_LOG_INFO(blackboard["foo_str"])
        else:
            yasmin.YASMIN_LOG_INFO("Blackboard does not yet contain 'foo_str'")

        yasmin.YASMIN_LOG_INFO("Finishing state BAR")
        return "outcome3"</code></pre>

            <h2>3. Create the Concurrence Container</h2>
            <p>Initialize ROS 2 and create a <code>Concurrence</code> container that executes FooState and BarState simultaneously. The <code>outcome_map</code> parameter defines how the combined outcomes are determined - in this case, we specify that when BarState produces <code>outcome3</code> and FooState produces <code>outcome2</code>, the concurrence should output <code>outcome5</code> to end execution. The <code>outcome_cb</code> callback provides additional control by allowing you to inspect individual state outcomes and make custom decisions. This two-level outcome resolution (map + callback) gives you flexibility: use the map for simple AND/OR logic, and the callback for complex conditional logic based on runtime state.</p>

            <pre><code class="language-python">rclpy.init()
set_ros_loggers()

sm = StateMachine(outcomes=["outcome4"])

foo_state = FooState()
bar_state = BarState()

concurrence_state = Concurrence(
    states={
        "FOO": foo_state,
        "BAR": bar_state,
    },
    default_outcome="defaulted",
    outcome_map={
        "outcome1": {
            "FOO": "outcome1",
            "BAR": "outcome3",
        },
        "outcome2": {
            "FOO": "outcome2",
            "BAR": "outcome3",
        },
    },
)</code></pre>

            <h2>4. Add Concurrence to State Machine</h2>
            <p>Add the concurrence container to the state machine with self-looping transitions for <code>outcome1</code> and <code>outcome2</code>, allowing multiple concurrent executions. The <code>defaulted</code> outcome exits the loop and terminates the state machine.</p>
            <pre><code class="language-python">sm.add_state(
    "CONCURRENCE",
    concurrence_state,
    transitions={
        "outcome1": "CONCURRENCE",
        "outcome2": "CONCURRENCE",
        "defaulted": "outcome4",
    },
)

YasminViewerPub(sm, "YASMIN_CONCURRENCE_DEMO")</code></pre>

            <h2>5. Execute the State Machine</h2>
            <p>Execute the state machine with exception handling to manage interruptions and ensure proper cleanup of resources.</p>
            <pre><code class="language-python">    # Publish FSM information for visualization
    viewer = YasminViewerPub(sm, "YASMIN_CONCURRENCE_DEMO")

    # Execute the FSM
    try:
        outcome = sm()
        yasmin.YASMIN_LOG_INFO(outcome)
    except KeyboardInterrupt:
        if sm.is_running():
            sm.cancel_state()
    finally:
        viewer.cleanup()
        del sm

        # Shutdown ROS 2 if it's running
        if rclpy.ok():
            rclpy.shutdown()


if __name__ == "__main__":
    main()</code></pre>

            <h2>6. Run the Demo</h2>
            <p>Execute the concurrence demonstration to observe how multiple states run in parallel and how their outcomes are combined.</p>
            <pre><code>ros2 run yasmin_demos concurrence_demo.py</code></pre>

            <h2>How It Works</h2>
            <p>The <code>outcome_map</code> defines when the concurrence completes:</p>
            <ul>
                <li>If FOO returns "outcome1" AND BAR returns "outcome3" â†’ concurrence returns "outcome1" and loops</li>
                <li>If FOO returns "outcome2" AND BAR returns "outcome3" â†’ concurrence returns "outcome2" and loops</li>
                <li>Otherwise â†’ returns "defaulted" and exits to "outcome4"</li>
            </ul>


    <div class="page-navigation">
        <a href="../python/remap_demo.html" class="nav-button prev">Python: Remapping Demo</a>
        <a href="../python/service_client_demo.html" class="nav-button next">Python: Service Client Demo</a>
    </div>
        </main>
    </div>

    <footer>
        <p>&copy; 2025 YASMIN Project. Licensed under GPL v3.0. | Documentation generated with <a href="../../doxygen.html" target="_blank">Doxygen</a></p>
    </footer>
</body>
</html>
