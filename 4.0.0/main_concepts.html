<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main Concepts - YASMIN</title>
    <link rel="stylesheet" href="style.css">
    <script src="sidebar.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="dark_mode.js"></script>
</head>
<body>
    <header>
        <a href="index.html" class="logo">
            <img src="logo.png" alt="YASMIN Logo">
            YASMIN
        </a>
        <div class="nav-links">
            <a href="index.html">Docs</a>
            <a href="https://github.com/uleroboticsgroup/yasmin" target="_blank">GitHub</a>
            <a href="doxygen.html" target="_blank">Doxygen</a>
            <button id="theme-toggle" title="Toggle Dark Mode">ðŸŒ™</button>
        </div>
    </header>

    <div class="container">
        <nav class="sidebar">
            <h3>Getting Started</h3>
            <ul>
                <li><a href="index.html">Introduction</a></li>
                <li><a href="main_concepts.html">Main Concepts</a></li>
                <li><a href="packages.html">Packages Overview</a></li>
                <li><a href="docker.html">Docker</a></li>
                <li><a href="xml_factory.html">XML</a></li>
            </ul>
            
            <h3>Tutorials</h3>
            <ul>
                <li><a href="tutorials.html">All Tutorials</a></li>
            </ul>

            <h3 class="collapsible">C++ Tutorials</h3>
            <ul>
                <li><a href="tutorials/cpp/basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="tutorials/cpp/remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="tutorials/cpp/concurrence_demo.html">Concurrence</a></li>
                <li><a href="tutorials/cpp/service_client_demo.html">Service Client</a></li>
                <li><a href="tutorials/cpp/action_client_demo.html">Action Client</a></li>
                <li><a href="tutorials/cpp/monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="tutorials/cpp/publisher_demo.html">Publisher</a></li>
                <li><a href="tutorials/cpp/parameters_demo.html">ROS Parameters</a></li>
                <li><a href="tutorials/cpp/nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="tutorials/cpp/factory_demo.html">Factory (XML)</a></li>
            </ul>

            <h3 class="collapsible">Python Tutorials</h3>
            <ul>
                <li><a href="tutorials/python/basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="tutorials/python/remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="tutorials/python/concurrence_demo.html">Concurrence</a></li>
                <li><a href="tutorials/python/service_client_demo.html">Service Client</a></li>
                <li><a href="tutorials/python/action_client_demo.html">Action Client</a></li>
                <li><a href="tutorials/python/monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="tutorials/python/publisher_demo.html">Publisher</a></li>
                <li><a href="tutorials/python/parameters_demo.html">ROS Parameters</a></li>
                <li><a href="tutorials/python/nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="tutorials/python/factory_demo.html">Factory (XML)</a></li>
            </ul>
            
            <h3>Tools</h3>
            <ul>
                <li><a href="yasmin_editor.html">YASMIN Editor</a></li>
                <li><a href="yasmin_factory.html">YASMIN Factory</a></li>
                <li><a href="yasmin_viewer.html">YASMIN Viewer</a></li>
            </ul>

            <h3>Resources</h3>
            <ul>
                <li><a href="citations.html">Citations</a></li>
            </ul>
        </nav>

        <main class="main-content content">
            <h1>Main Concepts</h1>
            
            <p>YASMIN (Yet Another State MachINe) is designed to simplify the creation of complex robot behaviors using state machines. Understanding the core concepts is essential for using the library effectively.</p>

            <h2>Finite State Machines (FSM)</h2>
            <p>A Finite State Machine is a mathematical model of computation. It is an abstract machine that can be in exactly one of a finite number of states at any given time. The FSM can change from one state to another in response to some inputs; the change from one state to another is called a transition.</p>
            <p>In the context of robotics, FSMs are used to define the behavior of a robot. Each state represents a specific task or mode of operation (e.g., "Idle", "Moving", "Grasping"), and transitions define how the robot switches between these tasks based on sensor data or internal logic.</p>
            <p>FSMs provide several key advantages for robot control: they offer a clear, visual representation of robot behavior that is easy to understand and debug; they ensure deterministic behavior where the robot's actions are predictable and reproducible; and they enable modular design where each state encapsulates a specific functionality that can be developed and tested independently. This makes FSMs particularly well-suited for complex robotic applications where reliability and maintainability are crucial.</p>
            <p>In YASMIN, FSMs are implemented as state machine objects that manage the execution flow. You define states, add them to the state machine with their transition logic, and then execute the state machine. The framework handles the state execution loop, transition management, and data sharing through the blackboard, allowing you to focus on implementing the behavior logic within each state.</p>

            <h2>Hierarchical Finite State Machines (HFSM)</h2>
            <p>As systems become more complex, a simple "flat" FSM can become unmanageable due to the explosion of states and transitions. Hierarchical Finite State Machines (HFSM) address this by allowing states to contain other state machines.</p>
            <p>In YASMIN, you can nest state machines within states. This allows you to encapsulate complex behaviors into reusable modules. For example, a "Navigation" state could internally be an FSM with states like "Plan Path", "Follow Path", and "Recover". The parent FSM only sees the high-level "Navigation" state.</p>
            <p>The hierarchical approach provides significant architectural benefits. It enables abstraction layers where high-level state machines deal with strategic decisions while nested state machines handle tactical execution details. This separation of concerns makes the overall system easier to understand, test, and maintain. Each nested state machine can be developed and validated independently before being integrated into the larger system.</p>
            <p>YASMIN's implementation of HFSM is particularly powerful because nested state machines are treated as regular states from the parent's perspective. They receive the same blackboard access, can use remapping just like simple states, and return outcomes that drive transitions in the parent machine. This uniformity means you can refactor a simple state into a complex nested state machine without changing the parent's logic, enabling iterative refinement of behaviors as requirements evolve.</p>
            <p>Hierarchical composition also facilitates team collaboration on large robotic systems. Different team members can work on different nested state machines simultaneously, with clear interfaces defined by the blackboard keys and outcomes. This modular structure supports parallel development and makes it easier to reuse proven behavior components across multiple robot applications.</p>

            <h2>Key Components in YASMIN</h2>

            <h3>State</h3>
            <p>The fundamental building block. A state performs a task and returns an <strong>outcome</strong>. In YASMIN, you create custom states by inheriting from the <code>State</code> class and implementing the <code>execute</code> method.</p>
            <p>Each state is designed to be self-contained and focused on a single responsibility. When you create a state, you define what inputs it needs from the blackboard, what outputs it produces, and what outcomes it can return. The <code>execute</code> method contains the core logic of the state - this could be anything from simple data processing to complex interactions with robot hardware or external services.</p>
            <p>States can be stateless (performing the same operation every time) or stateful (maintaining internal variables between executions). YASMIN supports both patterns, giving you flexibility in how you design your behaviors. For example, a counter state might maintain an internal count that increments on each execution, while a sensor reading state might be completely stateless, simply querying a sensor and returning the result each time.</p>

            <h3>Outcomes</h3>
            <p>Every state execution concludes with an outcome (a string). This outcome determines which transition is triggered. Common outcomes include "success", "failure", "aborted", or custom events like "target_detected". Outcomes are the glue that connects states together - they define the flow of execution through your state machine.</p>
            <p>You can define custom outcomes for your states to represent different completion scenarios. For example, a "GraspObject" state might have outcomes like "grasped", "object_not_found", "gripper_error", each leading to different next states or recovery behaviors. This flexibility allows you to model complex decision trees and error handling logic in a clear, explicit way.</p>

            <h3>Transitions</h3>
            <p>Transitions map the <strong>outcome</strong> of a state to the next state to be executed. This defines the flow of the application. When you add a state to a state machine, you specify a dictionary of transitions where each key is a possible outcome from that state, and the value is the name of the next state to execute. This creates a directed graph that represents your application's logic. Transitions can point to other states, loop back to the same state (useful for retry logic), or terminate the state machine by mapping to a final outcome. The transition mechanism is what makes YASMIN a true finite state machine, ensuring deterministic and predictable behavior flows.</p>

            <h3>Blackboard</h3>
            <p>The Blackboard is a shared memory space that allows states to exchange data. Since states are often independent classes, they need a mechanism to pass information (e.g., a target pose found by a "Perception" state needs to be passed to a "Move" state). The Blackboard stores key-value pairs that are accessible to all states in the FSM.</p>
            <p>One of the most powerful features of the Blackboard is <strong>remapping</strong>. Remapping allows you to connect states with different key names without modifying the state classes themselves. For example, if a state reads from <code>input_data</code> and another state writes to <code>sensor_reading</code>, you can remap <code>input_data</code> to <code>sensor_reading</code> when adding the state to the state machine. This enables:</p>
            <ul>
                <li><strong>State reusability:</strong> Use the same state class multiple times with different data sources by remapping keys</li>
                <li><strong>Data flow composition:</strong> Connect the output of one state to the input of another by remapping output keys to input keys</li>
                <li><strong>Clear separation:</strong> Keep state logic independent from data sources, making states more modular and testable</li>
                <li><strong>Flexible architecture:</strong> Change data flow without modifying state implementations</li>
            </ul>
            <p>When you add a state to a state machine using <code>add_state()</code>, you can provide a <code>remappings</code> dictionary that maps the state's internal key names to the actual blackboard keys. This is particularly useful when building complex state machines from reusable components or when integrating third-party states into your application.</p>

            <h3>Outcomes</h3>
            <p>Every state execution concludes with an outcome (a string). This outcome determines which transition is triggered. Common outcomes include "success", "failure", "aborted", or custom events like "target_detected". Outcomes are the glue that connects states together - they define the flow of execution through your state machine.</p>
            <p>You can define custom outcomes for your states to represent different completion scenarios. For example, a "GraspObject" state might have outcomes like "grasped", "object_not_found", "gripper_error", each leading to different next states or recovery behaviors. This flexibility allows you to model complex decision trees and error handling logic in a clear, explicit way.</p>

            <h2>State Machine Composition</h2>
            <p>YASMIN supports building complex behaviors by composing multiple state machines. You can nest state machines within other state machines, creating hierarchical structures. This composition allows you to:</p>
            <ul>
                <li><strong>Modularize behavior:</strong> Break down complex tasks into smaller, manageable state machines</li>
                <li><strong>Reuse behaviors:</strong> Create libraries of reusable state machine components that can be composed in different ways</li>
                <li><strong>Abstract complexity:</strong> Hide implementation details by encapsulating sub-behaviors in nested state machines</li>
                <li><strong>Scale applications:</strong> Build large-scale robot applications from well-tested, modular components</li>
            </ul>
            <p>For example, a high-level "PerformTask" state machine might contain nested state machines for "NavigateToLocation", "PerceiveEnvironment", and "ExecuteAction", each of which is a complete FSM with its own states and transitions. This hierarchical approach mirrors how humans break down complex problems into smaller sub-problems.</p>

            <h2>Concurrency</h2>
            <p>YASMIN provides a <code>Concurrence</code> container that allows multiple states to execute in parallel. This is useful when you need to perform multiple independent tasks simultaneously, such as monitoring sensors while executing an action. The Concurrence container manages the parallel execution and provides flexible outcome resolution - you can specify whether all states must succeed, if any state succeeding is sufficient, or implement custom logic to combine the outcomes of concurrent states.</p>
            <p>Concurrent states share the same blackboard, so you need to be careful about data access patterns. YASMIN handles thread safety for blackboard operations, but you should design your states to avoid conflicts when reading and writing shared data concurrently.</p>

        </main>
    </div>

    <footer>
        <p>&copy; 2025 YASMIN Project. Licensed under GPL v3.0. | Documentation generated with <a href="doxygen.html" target="_blank">Doxygen</a></p>
    </footer>
</body>
</html>
