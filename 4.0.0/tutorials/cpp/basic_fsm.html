<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Writing a Simple FSM (C++) - YASMIN</title>
    <link rel="stylesheet" href="../../style.css">
    <script src="../../sidebar.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script src="../../dark_mode.js"></script>
</head>
<body>
    <header>
        <a href="../../index.html" class="logo">
            <img src="../../logo.png" alt="YASMIN Logo">
            YASMIN
        </a>
        <div class="nav-links">
            <a href="../../index.html">Docs</a>
            <a href="https://github.com/uleroboticsgroup/yasmin" target="_blank">GitHub</a>
            <a href="../../doxygen.html" target="_blank">Doxygen</a>
            <button id="theme-toggle" title="Toggle Dark Mode">ðŸŒ™</button>
        </div>
    </header>

    <div class="container">
                        <nav class="sidebar">
            <h3>Getting Started</h3>
            <ul>
                <li><a href="../../index.html">Introduction</a></li>
                <li><a href="../../main_concepts.html">Main Concepts</a></li>
                <li><a href="../../packages.html">Packages Overview</a></li>
                <li><a href="../../docker.html">Docker</a></li>
                <li><a href="../../xml_factory.html">XML</a></li>
            </ul>
            
            <h3>Tutorials</h3>
            <ul>
                <li><a href="../../tutorials.html">All Tutorials</a></li>
            </ul>

            <h3 class="collapsible">C++ Tutorials</h3>
            <ul>
                <li><a href="basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="concurrence_demo.html">Concurrence</a></li>
                <li><a href="service_client_demo.html">Service Client</a></li>
                <li><a href="action_client_demo.html">Action Client</a></li>
                <li><a href="monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="publisher_demo.html">Publisher</a></li>
                <li><a href="parameters_demo.html">ROS Parameters</a></li>
                <li><a href="nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="factory_demo.html">Factory (XML)</a></li>
            </ul>

            <h3 class="collapsible">Python Tutorials</h3>
            <ul>
                <li><a href="../python/basic_fsm.html">Writing a Simple FSM</a></li>
                <li><a href="../python/remap_demo.html">Blackboard Remapping</a></li>
                <li><a href="../python/concurrence_demo.html">Concurrence</a></li>
                <li><a href="../python/service_client_demo.html">Service Client</a></li>
                <li><a href="../python/action_client_demo.html">Action Client</a></li>
                <li><a href="../python/monitor_demo.html">Monitor (Subscriber)</a></li>
                <li><a href="../python/publisher_demo.html">Publisher</a></li>
                <li><a href="../python/parameters_demo.html">ROS Parameters</a></li>
                <li><a href="../python/nav2_demo.html">Nav2 Demo</a></li>
                <li><a href="../python/factory_demo.html">Factory (XML)</a></li>
            </ul>
            
            <h3>Tools</h3>
            <ul>
                <li><a href="../../yasmin_editor.html">YASMIN Editor</a></li>
                <li><a href="../../yasmin_factory.html">YASMIN Factory</a></li>
                <li><a href="../../yasmin_viewer.html">YASMIN Viewer</a></li>
            </ul>

            <h3>Resources</h3>
            <ul>
                <li><a href="../../citations.html">Citations</a></li>
            </ul>
        </nav>

        <main class="main-content content">
            <h1><a href="https://github.com/uleroboticsgroup/yasmin/blob/main/yasmin_demos/src/yasmin_demo.cpp" target="_blank" style="color: inherit; text-decoration: none;">Writing a Simple FSM (C++)</a></h1>
            <p>This tutorial shows how to create a simple Finite State Machine (FSM) using YASMIN in C++. We will create two custom states, <code>FooState</code> and <code>BarState</code>, and transition between them. This example demonstrates the fundamental concepts of state machines: defining states with specific behaviors, managing state transitions, and sharing data between states using the blackboard.</p>

            <h2>1. Create the FooState</h2>
            <p>First, we define the <code>FooState</code> class inheriting from <code>yasmin::State</code>. This state will increment a counter and switch outcomes based on the counter value. The constructor initializes two possible outcomes: <code>"outcome1"</code> (to continue to BarState) and <code>"outcome2"</code> (to finish execution). In the <code>execute()</code> method, we check if the counter is less than 3 - if so, we increment it, store a message in the blackboard, and return <code>"outcome1"</code> to transition to BarState. After 3 executions, we return <code>"outcome2"</code> to end the state machine.</p>

            <pre><code class="language-cpp">/**
 * @brief Represents the "Foo" state in the state machine.
 *
 * This state increments a counter each time it is executed and
 * communicates the current count via the blackboard.
 */
class FooState : public yasmin::State {
public:
  /// Counter to track the number of executions.
  int counter;

  /**
   * @brief Constructs a FooState object, initializing the counter.
   */
  FooState() : yasmin::State({"outcome1", "outcome2"}), counter(0){};

  /**
   * @brief Executes the Foo state logic.
   *
   * This method logs the execution, waits for 3 seconds,
   * increments the counter, and sets a string in the blackboard.
   * The state will transition to either "outcome1" or "outcome2"
   * based on the current value of the counter.
   *
   * @param blackboard Shared pointer to the blackboard for state communication.
   * @return std::string The outcome of the execution: "outcome1" or "outcome2".
   */
  std::string
  execute(std::shared_ptr<yasmin::blackboard::Blackboard> blackboard) override {
    YASMIN_LOG_INFO("Executing state FOO");
    std::this_thread::sleep_for(std::chrono::seconds(3));

    if (this->counter < 3) {
      this->counter += 1;
      blackboard->set<std::string>("foo_str",
                                   "Counter: " + std::to_string(this->counter));
      return "outcome1";

    } else {
      return "outcome2";
    }
  };
};</code></pre>

            <h2>2. Create the BarState</h2>
            <p>Next, we define the <code>BarState</code>, which acts as an intermediary state in our FSM. This state has only one outcome: <code>"outcome3"</code>, which will transition back to FooState. In the <code>execute()</code> method, we retrieve the string stored by FooState from the blackboard and log it. This demonstrates how states can communicate by reading and writing shared data through the blackboard. After logging the message, the state returns <code>"outcome3"</code> to loop back to FooState.</p>

            <pre><code class="language-cpp">/**
 * @brief Represents the "Bar" state in the state machine.
 *
 * This state logs the value from the blackboard and provides
 * a single outcome to transition.
 */
class BarState : public yasmin::State {
public:
  /**
   * @brief Constructs a BarState object.
   */
  BarState() : yasmin::State({"outcome3"}) {}

  /**
   * @brief Executes the Bar state logic.
   *
   * This method logs the execution, waits for 3 seconds,
   * retrieves a string from the blackboard, and logs it.
   *
   * @param blackboard Shared pointer to the blackboard for state communication.
   * @return std::string The outcome of the execution: "outcome3".
   */
  std::string
  execute(std::shared_ptr<yasmin::blackboard::Blackboard> blackboard) override {
    YASMIN_LOG_INFO("Executing state BAR");
    std::this_thread::sleep_for(std::chrono::seconds(3));

    YASMIN_LOG_INFO(blackboard->get<std::string>("foo_str").c_str());

    return "outcome3";
  }
};</code></pre>

            <h2>3. Main Function</h2>
            <p>In the main function, we initialize ROS 2 and set up the complete state machine. First, we call <code>rclcpp::init()</code> to initialize the ROS 2 context and configure the YASMIN loggers. Then we create a <code>StateMachine</code> with <code>"outcome4"</code> as the terminal outcome. Using <code>add_state()</code>, we register our FooState and BarState, defining their transitions: FooState can transition to BarState (<code>outcome1</code>) or end the machine (<code>outcome2</code>), while BarState always loops back to FooState (<code>outcome3</code>). The YasminViewerPub enables real-time visualization of the state machine execution. Finally, we execute the state machine and handle any exceptions before shutting down ROS 2.</p>

            <pre><code class="language-cpp">int main(int argc, char *argv[]) {
  YASMIN_LOG_INFO("yasmin_demo");
  rclcpp::init(argc, argv);

  // Set ROS 2 logs
  yasmin_ros::set_ros_loggers();

  // Create a state machine
  auto sm = std::make_shared<yasmin::StateMachine>(
      std::initializer_list<std::string>{"outcome4"});

  // Cancel state machine on ROS 2 shutdown
  rclcpp::on_shutdown([sm]() {
    if (sm->is_running()) {
      sm->cancel_state();
    }
  });

  // Add states to the state machine
  sm->add_state("FOO", std::make_shared<FooState>(),
                {
                    {"outcome1", "BAR"},
                    {"outcome2", "outcome4"},
                });
  sm->add_state("BAR", std::make_shared<BarState>(),
                {
                    {"outcome3", "FOO"},
                });

  // Publish state machine updates
  yasmin_viewer::YasminViewerPub yasmin_pub(sm, "YASMIN_DEMO");

  // Execute the state machine
  try {
    std::string outcome = (*sm.get())();
    YASMIN_LOG_INFO(outcome.c_str());
  } catch (const std::exception &e) {
    YASMIN_LOG_WARN(e.what());
  }

  rclcpp::shutdown();
  return 0;
}</code></pre>

            <h2>4. Build and Run</h2>
            <p>Compile your ROS 2 package using colcon build and execute the demonstration to see the state machine in action, cycling through the FOO and BAR states.</p>
            <pre><code>ros2 run yasmin_demos yasmin_demo</code></pre>


    <div class="page-navigation">
        <div class="nav-button-placeholder"></div>
        <a href="remap_demo.html" class="nav-button next">C++: Remapping Demo</a>
    </div>
        </main>
    </div>

    <footer>
        <p>&copy; 2025 YASMIN Project. Licensed under GPL v3.0. | Documentation generated with <a href="../../doxygen.html" target="_blank">Doxygen</a></p>
    </footer>
</body>
</html>
